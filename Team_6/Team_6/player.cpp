//=============================================================================
// プレイヤー [player.cpp]
// Author : Nikaido Taichi
//=============================================================================

//=============================================================================
// インクルードファイル
// Author : Nikaido Taichi
//=============================================================================
#include "player.h"
#include "manager.h"
#include "keyboard.h"
#include "renderer.h"
#include "input.h"
#include "joypad.h"
#include "camera.h"
#include "game.h"
#include "sound.h"
#include "time.h"
#include "collision.h"
#include "fade.h"
#include "texture.h"
#include "resource_manager.h"
#include "motion.h"
#include "character_collision_box.h"
#include "object.h"
#include "item_baton.h"
#include "item_jailer_room_key.h"
#include "item_map.h"
#include "item_pc_room_key.h"
#include "item_prison_key.h"
#include "item_storage_key.h"
#include "player_ui.h"
#include "item_get_ui_prison_key.h"
#include "item_get_ui_baton.h"
#include "item_get_ui_jailer_key.h"
#include "item_get_ui_map.h"
#include "item_get_ui_pc_room_key.h"
#include "item_get_ui_storage_key.h"
#include "door_collision.h"

//=============================================================================
// マクロ定義
// Author : Nikaido Taichi
//=============================================================================
#define PLAYER_SPEED			(50.0f)									// プレイヤーの移動量
#define STICK_SENSITIVITY		(50.0f)									// スティック感度
#define SIZE					(D3DXVECTOR3 (100.0f,200.0f,100.0f))	// サイズ
#define STICK_INPUT_ZONE		(100)									// スティックの入力範囲
#define STICK_INPUT_ZONE_2		(1000)									// スティックの入力範囲
#define STICK_INPUT_ZERO		(0)										// スティックの入力値0
#define MIN_LIFE				(0)										// ライフの最小
#define LIFE					(100)									// ライフ
#define ANGLE_45				(D3DXToRadian(45.0f))					// 角度45
#define ANGLE_90				(D3DXToRadian(90.0f))					// 角度90
#define ANGLE_135				(D3DXToRadian(135.0f))					// 角度90
#define ANGLE_180				(D3DXToRadian(180.0f))					// 角度180
#define ANGLE_270				(D3DXToRadian(270.0f))					// 角度270
#define PARENT_NUM				(0)										// 親のナンバ
#define MOVE_MIN				(0.0f)									// 移動量の最小

//=============================================================================
// コンストラクタ
// Author : Nikaido Taichi
//=============================================================================
CPlayer::CPlayer(PRIORITY Priority) : CCharacter(Priority)
{
	m_nItemCount = ZERO_INT;								// アイテムの所持数
	m_nItemSortCount = ZERO_INT;							// アイテムソート用カウント
	m_nIncapacitatedTimeCount = ZERO_INT;					// 行動不能時間カウント
	m_bGoal = false;										// ゴール状態
	m_bIncapacitated = false;								// 行動不能状態
	memset(m_abGetItem, false, sizeof(m_abGetItem));		// アイテムを取得してるか
	memset(m_bItempCreate, false, sizeof(m_bItempCreate));	// アイテムポインタ生成したか
	memset(m_bUICreate, false, sizeof(m_bUICreate));	// UI生成状態
	for (int nCount = 0; nCount < ITEM_MAX; nCount++)
	{
		m_pItemGetUI[nCount] = nullptr;
	}
	m_pUI = nullptr;										// UIポインタ
	for (int nCount = 0; nCount < MAX_ITEM; nCount++)
	{
		m_pItem[nCount] = nullptr;							// アイテムポインタ
	}

}

//=============================================================================
// デストラクタ
// Author : Nikaido Taichi
//=============================================================================
CPlayer::~CPlayer()
{
}

//=============================================================================
// 初期化処理関数
// Author : Nikaido Taichi
//=============================================================================
HRESULT CPlayer::Init(D3DXVECTOR3 pos, D3DXVECTOR3 rot)
{
	// 初期化処理
	CCharacter::Init(pos, rot);

	// サイズ設定
	SetSize(SIZE);

	// ライフ設定
	SetLife(LIFE);

	// スピード設定
	SetSpeed(PLAYER_SPEED);

	CCharacterCollisionBox::Create(pos, rot, this);
	return S_OK;
}

//=============================================================================
// 終了処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::Uninit(void)
{
	// 終了
	CCharacter::Uninit();
	// UIポインタのnullptrチェック
	if (m_pUI != nullptr)
	{
		// UIポインタの終了処理関数呼び出し
		m_pUI->Uninit();
	}
}

//=============================================================================
// 更新関数処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::Update(void)
{
	// 更新
	CCharacter::Update();
	D3DXVECTOR3 Position = GetPos();
	// もし行動不能状態の場合
	if (m_bIncapacitated == true)
	{
		// もし行動不能時間カウントが指定時間より下の場合
		if (m_nIncapacitatedTimeCount <= INCAPACITATED_TIME)
		{
			// 加算する
			m_nIncapacitatedTimeCount++;
		}
		else
		{
			// 行動不能を解除する
			m_bIncapacitated = false;
		}
	}
	// マップとの当たり判定
	MapCollision();

	// 扉を開く処理
	DoorOpen();

	// UIポインタのnullptrチェック
	if (m_pUI != nullptr)
	{
		// UIポインタの更新処理関数呼び出し
		m_pUI->Update();
	}
	// 最大アイテム所持数分回す
	for (int nCount = 0; nCount < MAX_ITEM; nCount++)
	{
		// アイテムポインタのnullptrチェック
		if (m_pItem[nCount] != nullptr)
		{
			// アイテムの更新処理関数呼び出し
			m_pItem[nCount]->Update();
		}
		if (m_pItemGetUI[nCount] != nullptr)
		{
			m_pItemGetUI[nCount]->SetPosition(D3DXVECTOR3(Position.x, Position.y + 300.0f, Position.z));
		}
	}
}

//=============================================================================
// 描画処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::Draw(void)
{
	// 描画
	CCharacter::Draw();
}

//=============================================================================
// アイテム効果生成処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::ItemEffectCreate(int ItemGetList)
{
	switch (ItemGetList)
	{
		// 牢獄の鍵
	case ITEM_KEY_PRISON:
		if (m_abGetItem[ItemGetList] == true)
		{
			// 牢屋の鍵のポインタを生成する
			m_pItem[m_nItemCount] = CPrisonKey::Create();
			// アイテムカウントを加算する
			m_nItemCount++;
		}
		break;
		// 倉庫の鍵
	case ITEM_KEY_STORAGE:
		if (m_abGetItem[ItemGetList] == true)
		{
			// 倉庫効果のポインタを生成する
			m_pItem[m_nItemCount] = CStorageKey::Create();
			// アイテムカウントを加算する
			m_nItemCount++;
		}
		break;
		// 看守室の鍵
	case ITEM_KEY_JAILER_ROOM:
		if (m_abGetItem[ItemGetList] == true)
		{
			// 看守室効果のポインタを生成する
			m_pItem[m_nItemCount] = CJailerRoomKey::Create();
			// アイテムカウントを加算する
			m_nItemCount++;
		}
		break;
		// PC室の鍵

	case ITEM_KEY_CONTROL_ROOM:
		if (m_abGetItem[ItemGetList] == true)
		{
			// PC室効果のポインタを生成する
			m_pItem[m_nItemCount] = CPCRoomKey::Create();
			// アイテムカウントを加算する
			m_nItemCount++;
		}
		break;
		// 警棒
	case ITEM_BATON:
		if (m_abGetItem[ItemGetList] == true)
		{
			// 警棒効果のポインタを生成する
			m_pItem[m_nItemCount] = CItemBaton::Create();
			// アイテムカウントを加算する
			m_nItemCount++;
		}
		break;
		// マップ
	case ITEM_MAP:
		if (m_abGetItem[ItemGetList] == true)
		{
			// 地図効果のポインタを生成する
			m_pItem[m_nItemCount] = CItemMap::Create();
			// アイテムカウントを加算する
			m_nItemCount++;
		}
		break;
	default:
		break;
	}
}

//=============================================================================
// アイテム効果初期化処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::ItemEffectUninit(void)
{
	for (int nCount = 0; nCount < MAX_ITEM; nCount++)
	{
		// アイテムポインタのnullptrチェック
		if (m_pItem[nCount] != nullptr)
		{
			// アイテムの終了処理関数呼び出し
			m_pItem[nCount]->Uninit();
			// アイテムポインタを初期化する
			m_pItem[nCount] = nullptr;
		}
	}
	// アイテムカウントを初期化する
	m_nItemCount = ZERO_INT;
}

//=============================================================================
// アイテム削除処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::ItemDelete(int nPlayer)
{
	// キーボード取得
	CInputKeyboard *pKeyboard = CManager::GetKeyboard();
	// パッド取得
	CInputJoypad * pJoypad = CManager::GetJoypad();
	// 1Pのアイテム選択入力処理
	if (nPlayer == 0 && pKeyboard->GetTrigger(DIK_I) || pJoypad != nullptr && pJoypad->GetJoystickTrigger(CInputJoypad::JOY_BUTTON_L_TRIGGER, 0))
	{
		if (nPlayer == 0 && m_nItemSortCount > 0)
		{
			// アイテムソート用カウントを減算する
			m_nItemSortCount--;
		}
	}
	// 1Pのアイテム選択入力処理
	if (nPlayer == 0 && pKeyboard->GetTrigger(DIK_O) || pJoypad != nullptr && pJoypad->GetJoystickTrigger(CInputJoypad::JOY_BUTTON_R_TRIGGER, 0))
	{
		if (nPlayer == 0 && m_nItemSortCount < 2)
		{
			// アイテムソート用カウントを加算する
			m_nItemSortCount++;
		}
	}
	// 1P&2Pのアイテム削除入力処理
	if (nPlayer == 0 && pKeyboard->GetTrigger(DIK_P) || nPlayer == 1 && pKeyboard->GetTrigger(DIK_L) || pJoypad != nullptr && pJoypad->GetJoystickTrigger(CInputJoypad::JOY_BUTTON_Y,nPlayer))
	{
		// アイテムポインタのnullptrチェック
		if (m_pItem[m_nItemSortCount] != nullptr)
		{
			// UIを消す
			m_pUI->Uninit();
			// 選択しているアイテムの種類を取得する
			int nItemType = m_pItem[m_nItemSortCount]->GetItemType();
			// 選択しているアイテムの取得状態をfalseにする
			SetSubbGetItem(nItemType, false);
			// アイテムを生成する
			m_pItem[m_nItemSortCount]->ItemCreate(nPlayer);
			// アイテム効果初期化処理関数呼び出し
			ItemEffectUninit();
			// アイテムの最大数分回す
			for (int nCount = 0; nCount < ITEM_MAX; nCount++)
			{
				// アイテム効果生成処理関数呼び出し
				ItemEffectCreate(nCount);
			}
		}
	}
}

void CPlayer::ItemGetGuideUICreate(ITEM_GET_LIST Type)
{
	D3DXVECTOR3 Position = GetPos();
	// UI生成状態がfalseの場合
	if (m_bUICreate[Type] == false)
	{
		switch (Type)
		{
			// 牢屋の鍵
		case ITEM_KEY_PRISON:
			if (m_pItemGetUI[ITEM_KEY_PRISON] == nullptr)
			{
				m_pItemGetUI[ITEM_KEY_PRISON] = CItemGetUIPrisonKey::Create(D3DXVECTOR3(Position.x, Position.y + 300.0f, Position.z), D3DXVECTOR3(150.0f, 150.0f, 1.0f));
			}
			// UI生成状態をtrueにする
			m_bUICreate[Type] = true;
			break;
			// 倉庫の鍵
		case ITEM_KEY_STORAGE:
			if (m_pItemGetUI[ITEM_KEY_STORAGE] == nullptr)
			{
				m_pItemGetUI[ITEM_KEY_STORAGE] = CItemGetUIStorageKey::Create(D3DXVECTOR3(Position.x, Position.y + 300.0f, Position.z), D3DXVECTOR3(150.0f, 150.0f, 1.0f));
			}
			// UI生成状態をtrueにする
			m_bUICreate[Type] = true;
			break;
			// 看守の鍵
		case ITEM_KEY_JAILER_ROOM:
			if (m_pItemGetUI[ITEM_KEY_JAILER_ROOM] == nullptr)
			{
				m_pItemGetUI[ITEM_KEY_JAILER_ROOM] = CItemGetUIJailerKey::Create(D3DXVECTOR3(Position.x, Position.y + 300.0f, Position.z), D3DXVECTOR3(150.0f, 150.0f, 1.0f));
			}
			// UI生成状態をtrueにする
			m_bUICreate[Type] = true;
			break;
			// PC室の鍵

		case ITEM_KEY_CONTROL_ROOM:
			if (m_pItemGetUI[ITEM_KEY_CONTROL_ROOM] == nullptr)
			{

				m_pItemGetUI[ITEM_KEY_CONTROL_ROOM] = CItemGetUIPCRoomKey::Create(D3DXVECTOR3(Position.x, Position.y + 300.0f, Position.z), D3DXVECTOR3(150.0f, 150.0f, 1.0f));
			}
			// UI生成状態をtrueにする
			m_bUICreate[Type] = true;
			break;
			// 警棒
		case ITEM_BATON:
			if (m_pItemGetUI[ITEM_BATON] == nullptr)
			{
				m_pItemGetUI[ITEM_BATON] = CItemGetUIBaton::Create(D3DXVECTOR3(Position.x, Position.y + 300.0f, Position.z), D3DXVECTOR3(150.0f, 150.0f, 1.0f));
			}
			// UI生成状態をtrueにする
			m_bUICreate[Type] = true;
			break;
			// マップ
		case ITEM_MAP:
			if (m_pItemGetUI[ITEM_MAP] == nullptr)
			{
				m_pItemGetUI[ITEM_MAP] = CItemGetUIMap::Create(D3DXVECTOR3(Position.x, Position.y + 300.0f, Position.z), D3DXVECTOR3(150.0f, 150.0f, 1.0f));
			}
			// UI生成状態をtrueにする
			m_bUICreate[Type] = true;
			break;
		default:
			break;
		}
	}
}

void CPlayer::ItemGetGuideUIDelete(ITEM_GET_LIST Type)
{
	switch (Type)
	{
		// 牢屋の鍵
	case ITEM_KEY_PRISON:
		if (m_pItemGetUI[ITEM_KEY_PRISON] != nullptr)
		{
			m_pItemGetUI[ITEM_KEY_PRISON]->Uninit();
			m_pItemGetUI[ITEM_KEY_PRISON] = nullptr;
			// UI生成状態をfalseにする
			m_bUICreate[Type] = false;
		}



		break;
		// 倉庫の鍵
	case ITEM_KEY_STORAGE:
		if (m_pItemGetUI[ITEM_KEY_STORAGE] != nullptr)
		{
			m_pItemGetUI[ITEM_KEY_STORAGE]->Uninit();
			m_pItemGetUI[ITEM_KEY_STORAGE] = nullptr;
			// UI生成状態をfalseにする
			m_bUICreate[Type] = false;
		}



		break;
		// 看守の鍵
	case ITEM_KEY_JAILER_ROOM:
		if (m_pItemGetUI[ITEM_KEY_JAILER_ROOM] != nullptr)
		{
			m_pItemGetUI[ITEM_KEY_JAILER_ROOM]->Uninit();
			m_pItemGetUI[ITEM_KEY_JAILER_ROOM] = nullptr;
			// UI生成状態をfalseにする
			m_bUICreate[Type] = false;
		}



		break;
		// PC室の鍵


	case ITEM_KEY_CONTROL_ROOM:
		if (m_pItemGetUI[ITEM_KEY_CONTROL_ROOM] != nullptr)
		{


			m_pItemGetUI[ITEM_KEY_CONTROL_ROOM]->Uninit();
			m_pItemGetUI[ITEM_KEY_CONTROL_ROOM] = nullptr;
			// UI生成状態をfalseにする
			m_bUICreate[Type] = false;
		}

		break;
		// 警棒
	case ITEM_BATON:
		if (m_pItemGetUI[ITEM_BATON] != nullptr)
		{
			m_pItemGetUI[ITEM_BATON]->Uninit();
			m_pItemGetUI[ITEM_BATON] = nullptr;
			// UI生成状態をfalseにする
			m_bUICreate[Type] = false;
		}



		break;
		// マップ
	case ITEM_MAP:
		if (m_pItemGetUI[ITEM_MAP] != nullptr)
		{
			m_pItemGetUI[ITEM_MAP]->Uninit();
			m_pItemGetUI[ITEM_MAP] = nullptr;
			// UI生成状態をfalseにする
			m_bUICreate[Type] = false;
		}


		break;
	default:
		break;
	}
}

//=============================================================================
// 取得アイテム加算処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::SetAddbGetItem(int nItem, bool bGet)
{
	// プレイヤーのアイテム所得状態
	m_abGetItem[nItem] = bGet;
	// アイテム効果を生成
	ItemEffectCreate(nItem);
}

//=============================================================================
// 取得アイテム減算処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::SetSubbGetItem(int nItem, bool bGet)
{
	// プレイヤーのアイテム所得状態
	m_abGetItem[nItem] = bGet;
}

//=============================================================================
// マップとの当たり判定処理関数
// Author : Nikaido Taichi
//=============================================================================
void CPlayer::MapCollision(void)
{
	// CSceneのポインタ
	CScene *pScene = nullptr;

	// モデルの情報取得
	CModelAnime *pAnime = GetModelAnime(PARENT_NUM);

	// 位置取得
	D3DXVECTOR3 pos = GetPos();

	// 位置取得
	D3DXVECTOR3 posOld = GetOldPos();

	// サイズ取得
	D3DXVECTOR3 size = GetSize();

	// nullcheck
	if (pScene == nullptr)
	{
		// 先頭のポインタ取得
		pScene = GetTop(CScene::PRIORITY_MAP);

		// !nullcheck
		if (pScene != nullptr)
		{
			// Mapオブジェクトの当たり判定
			while (pScene != nullptr) // nullptrになるまで回す
			{
				// 現在のポインタ
				CScene *pSceneCur = pScene->GetNext();

				// 位置取得
				D3DXVECTOR3 ObjPos = ((CObject*)pScene)->GetPos();

				// サイズ取得
				D3DXVECTOR3 ObjSize = ((CObject*)pScene)->GetSize();

				//どこの面に当たったか取得
				//下
				if (CCollision::ActiveCollisionRectangleAndRectangle(pos, posOld, ObjPos, size, ObjSize) == CCollision::SURFACE_DOWN)
				{
					// 移動量0
					GetMove().y = MOVE_MIN;

					// 位置
					pos.y = (-ObjSize.y / DIVIDE_2 + ObjPos.y) - (size.y / DIVIDE_2);

					// 位置設定
					SetPos(pos);
				}
				// 上
				else if (CCollision::ActiveCollisionRectangleAndRectangle(pos, posOld, ObjPos, size, ObjSize) == CCollision::SURFACE_UP)
				{
					// 移動量0
					GetMove().y = MOVE_MIN;

					// 位置
					pos.y = (ObjSize.y / DIVIDE_2 + ObjPos.y) + (size.y / DIVIDE_2);

					// 位置設定
					SetPos(pos);
				}
				// 左
				else if (CCollision::ActiveCollisionRectangleAndRectangle(pos, posOld, ObjPos, size, ObjSize) == CCollision::SURFACE_LEFT)
				{
					// 移動量0
					GetMove().x = MOVE_MIN;

					// 位置
					pos.x = (-ObjSize.x / DIVIDE_2 + ObjPos.x) - (size.x / DIVIDE_2);

					// 位置設定
					SetPos(pos);
				}
				// 右
				else if (CCollision::ActiveCollisionRectangleAndRectangle(pos, posOld, ObjPos, size, ObjSize) == CCollision::SURFACE_RIGHT)
				{
					// 移動量0
					GetMove().x = MOVE_MIN;

					// 位置
					pos.x = (ObjSize.x / DIVIDE_2 + ObjPos.x) + (size.x / DIVIDE_2);

					// 位置設定
					SetPos(pos);
				}
				// 手前
				else if (CCollision::ActiveCollisionRectangleAndRectangle(pos, posOld, ObjPos, size, ObjSize) == CCollision::SURFACE_PREVIOUS)
				{
					// 移動量0
					GetMove().z = MOVE_MIN;

					// 位置
					pos.z = (-ObjSize.z / DIVIDE_2 + ObjPos.z) - (size.z / DIVIDE_2);

					// 位置設定
					SetPos(pos);
				}
				// 奥
				else if (CCollision::ActiveCollisionRectangleAndRectangle(pos, posOld, ObjPos, size, ObjSize) == CCollision::SURFACE_BACK)
				{
					// 移動量0
					GetMove().z = MOVE_MIN;

					// 位置
					pos.z = (ObjSize.z / DIVIDE_2 + ObjPos.z) + (size.z / DIVIDE_2);

					// 位置設定
					SetPos(pos);
				}

				// 次のポインタ取得
				pScene = pSceneCur;
			}
		}
	}
}
//=============================================================================
// 扉を開く処理
// Author : SugawaraTsukasa
//=============================================================================
void CPlayer::DoorOpen(void)
{
	// CSceneのポインタ
	CScene *pScene = nullptr;

	// 位置取得
	D3DXVECTOR3 pos = GetPos();

	// サイズ取得
	D3DXVECTOR3 size = GetSize();

	// nullcheck
	if (pScene == nullptr)
	{
		// 先頭のポインタ取得
		pScene = GetTop(CScene::PRIORITY_OBJ_COLLISION);

		// !nullcheck
		if (pScene != nullptr)
		{
			// 判定用オブジェ取得
			while (pScene != nullptr) // nullptrになるまで回す
			{
				// 現在のポインタ
				CScene *pSceneCur = pScene->GetNext();

				// 位置取得
				D3DXVECTOR3 ObjPos = ((CDoor_Collision*)pScene)->GetPos();

				// サイズ取得
				D3DXVECTOR3 ObjSize = ((CDoor_Collision*)pScene)->GetSize();

				// 立方体の判定
				if (CCollision::CollisionRectangleAndRectangle(pos, ObjPos, size, ObjSize) == true)
				{
					// 扉がロック状態の場合
					if (((CDoor_Collision*)pScene)->GetLock() == true)
					{
						// キーボード取得
						CInputKeyboard *pKeyboard = CManager::GetKeyboard();

						// ドアの種類取得
						int nDoorType = ((CDoor_Collision*)pScene)->GetType();

						// ドアに対応したアイテムを所持している場合
						if (m_abGetItem[ITEM_KEY_PRISON] == true && nDoorType == CDoor_Collision::TYPE_PRISON ||

							m_abGetItem[ITEM_KEY_STORAGE] == true && nDoorType == CDoor_Collision::TYPE_STORAGE ||
							m_abGetItem[ITEM_KEY_JAILER_ROOM] == true && nDoorType == CDoor_Collision::TYPE_JAILER_ROOM ||
							m_abGetItem[ITEM_KEY_CONTROL_ROOM] == true && nDoorType == CDoor_Collision::TYPE_CONTROL_ROOM ||
							m_abGetItem[ITEM_BATON] == true && nDoorType == CDoor_Collision::TYPE_SWITCH)
						{
							// Fが押された場合
							if (pKeyboard->GetTrigger(DIK_F))
							{
								// 扉を開く
								((CDoor_Collision*)pScene)->Open();
							}
						}
					}
				}
				// 次のポインタ取得
				pScene = pSceneCur;
			}
		}
	}
}